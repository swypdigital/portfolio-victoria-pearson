#!/usr/bin/env node
/**
 * VibeSdk Engine Wrapper
 *
 * Purpose: Wraps Cloudflare VibeSdk for GenCraft API integration
 * Engine Type: Webapp Generator (React/Vue/Svelte)
 * Status: Production-ready (Phase 2 MVP - Mock Mode)
 *
 * Architecture:
 * - Phase 2 MVP: Returns mock React webapp code for VIBE OS integration testing
 * - Phase 3: Will call live VibeSdk API at build.cloudflare.dev
 * - Phase 4: Will fork VibeSdk for custom GenCraft document generation
 *
 * Input: JSON via stdin
 * {
 *   "description": string,
 *   "options": {
 *     "framework": "react" | "vue" | "svelte" | "nextjs" | "auto",
 *     "complexity": "simple" | "medium" | "complex",
 *     "features": string[]
 *   }
 * }
 *
 * Output: JSON to stdout
 * {
 *   "success": boolean,
 *   "code": string,
 *   "metadata": {
 *     "framework": string,
 *     "fileCount": number,
 *     "linesOfCode": number,
 *     "cost": number,
 *     "tokensUsed": number,
 *     "generationTime": number
 *   },
 *   "error"?: string
 * }
 */

import { readFileSync } from 'fs';

// Read input from stdin
let inputData = '';
process.stdin.on('data', chunk => inputData += chunk);
process.stdin.on('end', async () => {
  try {
    const input = JSON.parse(inputData);
    const result = await generateWebapp(input);
    console.log(JSON.stringify(result, null, 2));
    process.exit(0);
  } catch (error) {
    console.error(JSON.stringify({
      success: false,
      error: error.message
    }));
    process.exit(1);
  }
});

/**
 * Generate webapp using VibeSdk architecture
 * Phase 2: Mock implementation for VIBE OS integration testing
 */
async function generateWebapp(input) {
  const startTime = Date.now();
  const { description, options = {} } = input;

  // Validate input
  if (!description || typeof description !== 'string') {
    throw new Error('Description is required and must be a string');
  }

  // Default options
  const framework = options.framework || 'auto';
  const complexity = options.complexity || 'medium';
  const features = options.features || [];

  // Auto-detect framework from description
  const detectedFramework = detectFramework(description, framework);

  // Generate mock React webapp
  // TODO Phase 3: Replace with actual VibeSdk API call to build.cloudflare.dev
  const code = generateMockReactApp(description, detectedFramework, complexity, features);

  // Calculate metadata
  const linesOfCode = code.split('\n').length;
  const fileCount = estimateFileCount(complexity);
  const tokensUsed = Math.floor(linesOfCode * 1.5); // Rough estimate
  const cost = calculateCost(tokensUsed, complexity);

  return {
    success: true,
    code,
    metadata: {
      framework: detectedFramework,
      fileCount,
      linesOfCode,
      cost,
      tokensUsed,
      generationTime: Date.now() - startTime
    }
  };
}

/**
 * Detect framework from description or default
 */
function detectFramework(description, frameworkHint) {
  if (frameworkHint !== 'auto') {
    return frameworkHint;
  }

  const desc = description.toLowerCase();
  if (desc.includes('react') || desc.includes('jsx')) return 'react';
  if (desc.includes('vue')) return 'vue';
  if (desc.includes('svelte')) return 'svelte';
  if (desc.includes('next')) return 'nextjs';

  // Default to React (most popular)
  return 'react';
}

/**
 * Generate mock React application
 * Phase 2: Simple but functional mock for testing
 * Phase 3: Will call VibeSdk API
 */
function generateMockReactApp(description, framework, complexity, features) {
  const componentName = extractComponentName(description);

  return `import React, { useState } from 'react';
import './App.css';

/**
 * ${componentName}
 * Generated by GenCraft v3.0 via VibeSdk Engine
 *
 * Description: ${description}
 * Framework: ${framework}
 * Complexity: ${complexity}
 * Features: ${features.join(', ') || 'none'}
 */
function ${componentName}() {
  const [count, setCount] = useState(0);
  const [isDarkMode, setIsDarkMode] = useState(false);

  return (
    <div className={\`app \${isDarkMode ? 'dark' : 'light'}\`}>
      <header className="app-header">
        <h1>${componentName}</h1>
        <p>${description}</p>
      </header>

      <main className="app-content">
        <div className="counter-section">
          <button onClick={() => setCount(count - 1)}>-</button>
          <span className="count">{count}</span>
          <button onClick={() => setCount(count + 1)}>+</button>
        </div>

        <div className="theme-toggle">
          <label>
            <input
              type="checkbox"
              checked={isDarkMode}
              onChange={(e) => setIsDarkMode(e.target.checked)}
            />
            Dark Mode
          </label>
        </div>

        ${generateFeatureComponents(features)}
      </main>

      <footer className="app-footer">
        <p>Generated by GenCraft v3.0 â€¢ VibeSdk Engine</p>
      </footer>
    </div>
  );
}

export default ${componentName};`;
}

/**
 * Extract component name from description
 */
function extractComponentName(description) {
  // Try to extract a meaningful component name
  const words = description
    .replace(/[^a-zA-Z0-9\s]/g, '')
    .split(/\s+/)
    .filter(w => w.length > 2)
    .slice(0, 3)
    .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase());

  return words.length > 0 ? words.join('') + 'App' : 'MyApp';
}

/**
 * Generate feature-specific components
 */
function generateFeatureComponents(features) {
  if (!features || features.length === 0) {
    return '';
  }

  return `
        <div className="features-section">
          <h2>Features</h2>
          <ul>
            ${features.map(f => `<li>${f}</li>`).join('\n            ')}
          </ul>
        </div>`;
}

/**
 * Estimate file count based on complexity
 */
function estimateFileCount(complexity) {
  switch (complexity) {
    case 'simple': return 3;
    case 'medium': return 8;
    case 'complex': return 15;
    default: return 8;
  }
}

/**
 * Calculate generation cost
 * Based on VibeSdk pricing model
 */
function calculateCost(tokensUsed, complexity) {
  const baseRate = 0.00002; // $0.02 per 1000 tokens (GPT-4 Turbo pricing)
  const complexityMultiplier = {
    simple: 1.0,
    medium: 1.5,
    complex: 2.5
  }[complexity] || 1.5;

  return parseFloat((tokensUsed * baseRate * complexityMultiplier).toFixed(4));
}
